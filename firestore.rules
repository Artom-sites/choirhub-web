rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions (Pure Claims - 0 Reads) ---

    // Check if user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Super Admin via Claims
    function isSuperAdmin() {
      return isSignedIn() && 
             request.auth.token.keys().hasAny(['superAdmin']) &&
             request.auth.token.superAdmin == true;
    }

    // Check Membership via Claims ONLY (No Database Calls)
    function isMemberOfChoir(choirId) {
      return isSignedIn() &&
             request.auth.token.keys().hasAny(['choirs']) &&
             choirId in request.auth.token.choirs;
    }

    // Check Admin Role via Claims ONLY (No Database Calls)
    function isChoirAdmin(choirId) {
      return isMemberOfChoir(choirId) &&
             request.auth.token.choirs[choirId] in ['admin', 'regent', 'head'];
    }

    // --- Collection Rules ---

    // 1. Users Collection
    match /users/{userId} {
      allow read: if request.auth.uid == userId || isSuperAdmin();
      // Allow update ONLY if NOT modifying sensitive fields (memberships, choirId, role, email)
      allow update: if (request.auth.uid == userId || isSuperAdmin()) &&
                       (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['memberships', 'choirId', 'role', 'email']));
      
      // Allow create? Usually handled by auth trigger, but if client does it:
      allow create: if request.auth.uid == userId;
    }

    // 2. Choirs Collection
    match /choirs/{choirId} {
      allow read: if isMemberOfChoir(choirId) || isSuperAdmin();
      allow create: if isSignedIn();
      allow update: if isChoirAdmin(choirId) || isSuperAdmin();
      allow delete: if isSuperAdmin(); // Only SuperAdmin can delete choirs for now

      // Songs (choir repertoire)
      match /songs/{songId} {
        allow read: if isMemberOfChoir(choirId);
        allow write: if isChoirAdmin(choirId) || isSuperAdmin();
      }
      
      // Local Songs (choir private)
      match /local_songs/{songId} {
        allow read: if isMemberOfChoir(choirId);
        allow write: if isChoirAdmin(choirId) || isSuperAdmin();
      }

      // Services
      match /services/{serviceId} {
        allow read: if isMemberOfChoir(choirId);
        allow create, delete: if isChoirAdmin(choirId) || isSuperAdmin();
        // Members can update their own attendance (confirmedMembers/absentMembers only)
        allow update: if isChoirAdmin(choirId) || isSuperAdmin() || (
          isMemberOfChoir(choirId) && 
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['confirmedMembers', 'absentMembers'])
        );
      }

      // Notifications
      match /notifications/{notificationId} {
        allow read: if isMemberOfChoir(choirId);
        allow create: if isChoirAdmin(choirId) || isSuperAdmin();
        // Members can mark notifications as read (readBy field)
        allow update: if isMemberOfChoir(choirId);
      }
      
      // Members subcollection (Purely for data storage/listing, not for permission checks anymore)
      match /members/{memberId} {
        allow read: if isMemberOfChoir(choirId);
        allow write: if isChoirAdmin(choirId) || isSuperAdmin();
      }
    }

    // 3. Global Songs (Public Archive)
    match /global_songs/{songId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }

    // 4. MSC Catalog (approved songs destination)
    match /mscCatalog/{songId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }

    // 5. Pending Songs (Community Submissions)
    match /pending_songs/{songId} {
      allow create: if isSignedIn();
      // Submitter can read their own; super admin can read all
      allow read: if isSuperAdmin() || (isSignedIn() && resource.data.submittedBy == request.auth.uid);
    }
  }
}
